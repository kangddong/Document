# Model-View-Controller

모델-뷰-컨트롤러 디자인 패턴(MVC)은 꽤 오래되었습니다. 그것의 변형은 적어도 스몰토크의 초창기부터 존재해 왔다. 이는 애플리케이션의 글로벌 아키텍처와 관련이 있고 애플리케이션에서 수행하는 일반적인 역할에 따라 객체를 분류한다는 점에서 높은 수준의 패턴입니다. 그것은 또한 몇 가지, 더 기본적인 패턴을 포함한다는 면에서 복합 패턴이다.

객체 지향 프로그램은 MVC 디자인 패턴을 디자인에 맞게 조정함으로써 여러 가지 방법으로 이점을 얻습니다. 이러한 프로그램의 많은 객체는 더 재사용 가능한 경향이 있으며 인터페이스가 더 잘 정의되는 경향이 있습니다. 프로그램은 전반적으로 변화하는 요구 사항에 더 잘 적응할 수 있습니다. 즉, MVC를 기반으로 하지 않는 프로그램보다 더 쉽게 확장할 수 있습니다. 게다가, 바인딩, 문서 아키텍처 및 스크립팅 가능성과 같은 Cocoa의 많은 기술과 아키텍처는 MVC를 기반으로 하며 사용자 지정 객체가 MVC에 의해 정의된 역할 중 하나를 수행해야 합니다.

## 객체들의 역활과 관계

MVC 디자인 패턴은 세 가지 유형의 객체가 있다고 생각합니다: 모델 객체, 뷰 객체 및 컨트롤러 객체. MVC 패턴은 이러한 유형의 객체가 애플리케이션과 통신 라인에서 수행하는 역할을 정의합니다. 응용 프로그램을 설계할 때, 주요 단계는 이 세 그룹 중 하나에 속하는 객체를 선택하거나 사용자 지정 클래스를 만드는 것입니다. 세 가지 유형의 객체 각각은 추상적인 경계에 의해 다른 객체와 분리되며 이러한 경계를 넘어 다른 유형의 객체와 통신합니다.

### 모델 객체는 데이터와 기본 동작을 캡슐화합니다.

모델 객체는 특별한 지식과 전문성을 나타냅니다. 그들은 애플리케이션의 데이터를 보유하고 그 데이터를 조작하는 논리를 정의합니다. 잘 설계된 MVC 애플리케이션은 모든 중요한 데이터를 모델 객체에 캡슐화합니다. 애플리케이션의 영구 상태의 일부인 모든 데이터(그 영구 상태가 파일에 저장되든 데이터베이스에 저장되든)는 데이터가 애플리케이션에 로드되면 모델 객체에 상주해야 합니다. 그것들은 특정 문제 영역과 관련된 지식과 전문성을 나타내기 때문에 재사용 가능한 경향이 있다.

이상적으로, 모델 객체는 그것을 제시하고 편집하는 데 사용되는 사용자 인터페이스에 명시적으로 연결되어 있지 않다. 예를 들어, 만약 당신이 사람을 나타내는 모델 객체를 가지고 있다면(당신이 주소록을 쓰고 있다고 가정해 봅시다), 당신은 생년월일을 저장하고 싶을 수도 있습니다. 그것은 당신의 Person 모델 객체에 저장하는 것이 좋습니다. 그러나, 날짜 형식 문자열이나 그 날짜가 어떻게 제시될지에 대한 다른 정보를 저장하는 것이 아마도 다른 곳에서 더 나을 것이다.

실제로, 이 분리가 항상 최선은 아니며, 여기에는 유연성의 여지가 있지만, 일반적으로 모델 객체는 인터페이스 및 프레젠테이션 문제와 관련이 없어야 합니다. 약간의 예외가 합리적인 한 가지 예는 표시된 그래픽을 나타내는 모델 객체가 있는 도면 응용 프로그램입니다. 그래픽 객체가 존재하는 주요 이유는 시각적인 것을 정의하기 위해서 자신을 그리는 방법을 아는 것이 합리적입니다. 그러나 이 경우에도 그래픽 객체는 특정 뷰나 다른 뷰에 전혀 의존해서는 안 되며, 언제 자신을 그려야 하는지 아는 책임을 져야 안 됩니다. 그들은 그들을 제시하고자 하는 뷰 객체에 의해 스스로를 그리도록 요청 받아야 한다.
### 뷰 객체는 유저에게 정보를 표시한다

뷰 객체는 애플리케이션 모델의 데이터를 표시하는 방법을 알고 있으며, 사용자가 편집할 수 있도록 허용할 수 있습니다. 뷰는 그것이 보여주는 데이터를 저장하는 것에 대한 책임을 져야 한다. (물론, 이것은 뷰가 실제로 표시하는 데이터를 저장하지 않는다는 것을 의미하지는 않습니다. 뷰는 성능상의 이유로 데이터를 캐시하거나 유사한 트릭을 수행할 수 있습니다. 뷰 객체는 모델 객체의 한 부분만 표시하거나 전체 모델 객체 또는 심지어 많은 다른 모델 객체를 표시하는 역할을 할 수 있습니다. 뷰는 다양한 종류가 있다.

뷰 객체는 재사용 및 구성 가능한 경향이 있으며, 애플리케이션 간의 일관성을 제공합니다. Cocoa에서 AppKit 프레임워크는 많은 수의 뷰 객체를 정의하고 인터페이스 빌더 라이브러리에서 많은 객체를 제공합니다. [NSButton](https://developer.apple.com/documentation/appkit/nsbutton) 객체와 같은 AppKit의 객체를 재사용함으로써 애플리케이션의 버튼이 다른 Cocoa 애플리케이션의 버튼과 동일하게 작동하도록 보장하여 애플리케이션 전반에 걸쳐 모양과 동작에서 높은 수준의 일관성을 보장합니다.

뷰는 모델을 올바르게 표시하고 있는지 확인해야 합니다. 결과적으로, 그것은 보통 모델의 변화에 대해 알아야 한다. 모델 객체는 특정 뷰 객체에 연결되어서는 안 되기 때문에 변경되었음을 나타내는 일반적인 방법이 필요합니다.
### 컨트롤러 객체는 모델을 뷰에 연결합니다. <a id="Controller-Objects Tie-the-Model-to-the-View"></a>

컨트롤러 객체는 애플리케이션의 뷰 객체와 모델 객체 사이의 중개자 역할을 합니다. 컨트롤러는 뷰가 표시해야 할 모델 객체에 접근할 수 있도록 돕고, 모델의 변경 사항을 뷰가 알 수 있도록 전달하는 역할을 맡습니다. 컨트롤러 객체는 또한 애플리케이션에 대한 설정 및 조정 작업을 수행하고 다른 객체의 수명 주기를 관리할 수 있습니다

일반적인 코코아 MVC 설계에서 사용자가 값을 입력하거나 뷰 객체를 통해 선택을 표시하면 해당 값 또는 선택이 컨트롤러 객체로 전달됩니다. 컨트롤러 객체는 사용자 입력을 애플리케이션별 방식으로 해석한 다음 모델 객체에 이 뷰의 입력으로 무엇을 해야 하는지 알려줄 수 있습니다(예: "새 값 추가" 또는 "현재 레코드 삭제") 또는 모델 객체가 속성 중 하나에 변경된 값을 반영하도록 할 수 있습니다. 이 동일한 사용자 입력을 기반으로 일부 컨트롤러 객체는 버튼이 자체를 비활성화하도록 지시하는 것과 같이 뷰 객체에 모양이나 동작의 측면을 변경하도록 지시할 수도 있습니다. 반대로, 모델 객체가 변경될 때 - 예를 들어, 새로운 데이터 소스가 액세스되는 경우 - 모델 객체는 일반적으로 그 변경 사항을 컨트롤러 객체에 전달하고, 컨트롤러 객체는 그에 따라 하나 이상의 뷰 객체를 업데이트하도록 요청합니다.

컨트롤러 객체는 일반적인 유형에 따라 재사용 가능하거나 재사용 불가능할 수 있습니다. [코코아 컨트롤러 객체의 유형](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html#//apple_ref/doc/uid/TP40010810-CH14-SW7)은 코코아의 다양한 유형의 컨트롤러 객체를 설명합니다.

### 역할 합성하기

객체가 수행하는 MVC 역할을 병합하여 객체가 컨트롤러와 뷰 역할을 모두 수행하도록 만들 수 있습니다. 이 경우 뷰 컨트롤러라고 불립니다. 같은 방식으로, 당신은 또한 모델-컨트롤러 객체를 가질 수 있습니다. 일부 응용 프로그램의 경우, 이와 같은 역할을 결합하는 것은 수용 가능한 설계입니다.

모델 컨트롤러는 주로 모델 레이어에 관심을 가진 컨트롤러입니다. 그것은 모델을 "소유"한다; 그것의 주요 책임은 모델을 관리하고 뷰 객체와 통신하는 것이다. 모델 전체에 적용되는 작업 방법은 일반적으로 모델 컨트롤러에서 구현됩니다. 문서 아키텍처는 이러한 여러 가지 방법을 제공합니다. 예를 들어, [NSDocument](https://developer.apple.com/documentation/appkit/nsdocument) 객체(문서 아키텍처의 중심 부분)는 파일 저장과 관련된 작업 방법을 자동으로 처리합니다.

뷰 컨트롤러는 주로 뷰 레이어와 관련된 컨트롤러입니다. 그것은 인터페이스(뷰)를 "소유"한다; 그것의 주요 책임은 인터페이스를 관리하고 모델과 소통하는 것이다. 뷰에 표시되는 데이터와 관련된 액션 메서드는 일반적으로 뷰 컨트롤러에서 구현됩니다. [NSWindowController](https://developer.apple.com/documentation/appkit/nswindowcontroller) 객체(또한 문서 아키텍처의 일부)는 뷰 컨트롤러의 예입니다.

[MVC 애플리케이션에 대한 설계 지침](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html#//apple_ref/doc/uid/TP40010810-CH14-SW14)은 MVC 역할이 병합된 객체에 관한 몇 가지 설계 조언을 제공합니다.


{% hint style="info" %} 
**Further Reading**
문서 기반 응용 프로그램 개요는 다른 관점에서 모델 컨트롤러와 뷰 컨트롤러의 차이점에 대해 논의합니다. {% endhint %}

## 코코아 컨트롤러 객체의 타입들

<a href="#Controller-Objects Tie-the-Model-to-the-View">컨트롤러 객체는 모델을 뷰에 연결합니다.</a>  컨트롤러 객체의 추상적인 윤곽을 스케치하지만 실제로는 그림이 훨씬 더 복잡합니다. 코코아에는 두 가지 일반적인 종류의 컨트롤러 개체가 있습니다: 중재 컨트롤러와 조정 컨트롤러. 각 종류의 컨트롤러 객체는 서로 다른 클래스 세트와 연관되어 있으며 각각 다른 동작 범위를 제공합니다.

중재 컨트롤러는 일반적으로 [NSController](https://developer.apple.com/documentation/appkit/nscontroller)class에서 상속되는 객체입니다. 중재 컨트롤러 객체는 코코아 바인딩 기술에 사용됩니다. 그들은 뷰 객체와 모델 객체 간의 데이터 흐름을 촉진하거나 중재합니다.

**iOS Note:** AppKit implements the `NSController` class and its subclasses. These classes and the bindings technology are not available in iOS.

중재 컨트롤러는 일반적으로 인터페이스 빌더 라이브러리에서 드래그하는 기성 개체입니다. 이러한 객체를 구성하여 뷰 객체의 속성과 컨트롤러 객체의 속성 간의 바인딩을 설정한 다음 해당 컨트롤러 속성과 모델 객체의 특정 속성 간의 바인딩을 설정할 수 있습니다. 결과적으로, 사용자가 뷰 객체에 표시된 값을 변경하면, 새로운 값은 중재 컨트롤러를 통해 저장을 위해 모델 객체에 자동으로 전달되며, 모델의 속성이 값을 변경하면 해당 변경 사항은 표시를 위해 뷰에 전달됩니다. 추상적인 NSController 클래스와 그 구체적인 하위 클래스([NSObjectController](https://developer.apple.com/documentation/appkit/nsobjectcontroller), [NSArrayController](https://developer.apple.com/documentation/appkit/nsarraycontroller), [NSUserDefaultsController](https://developer.apple.com/documentation/appkit/nsuserdefaultscontroller), 및 [NSTreeController](https://developer.apple.com/documentation/appkit/nstreecontroller))는 변경 사항을 커밋 및 폐기하는 기능 및 선택 및 자리 표시자 값 관리와 같은 지원 기능을 제공합니다.


조정 컨트롤러는 일반적으로 [NSWindowController](https://developer.apple.com/documentation/appkit/nswindowcontroller) 또는 [NSDocumentController](https://developer.apple.com/documentation/appkit/nsdocumentcontroller)객체(AppKit에서만 사용 가능) 또는 [NSObject](https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSObject/Description.html#//apple_ref/occ/cl/NSObject)의 사용자 지정 하위 클래스의 인스턴스입니다. 응용 프로그램에서의 역할은 전체 응용 프로그램 또는 nib 파일에서 보관되지 않은 개체와 같은 응용 프로그램의 일부의 기능을 감독하거나 조정하는 것입니다. 조정 컨트롤러는 다음과 같은 서비스를 제공합니다:
- 위임 메시지에 응답하고 알림 관찰하기
    
- 액션 메시지에 응답하기
    
- 소유한 객체의 수명 주기 관리 (예를 들어, 적절한 시기에 방출)
    
- 객체 간의 연결 설정 및 기타 설정 작업 수행

`NSWindowController` 및 `NSDocumentController`는 문서 기반 애플리케이션을 위한 Cocoa 아키텍처의 일부인 클래스입니다. 이러한 클래스의 인스턴스는 위에 나열된 여러 서비스에 대한 기본 구현을 제공하며, 더 많은 애플리케이션 특정 동작을 구현하기 위해 하위 클래스를 생성할 수 있습니다. `NSWindowController` 객체를 사용하여 문서 아키텍처를 기반으로 하지 않는 애플리케이션에서 창을 관리할 수도 있습니다.

조정 컨트롤러는 종종 nib 파일에 보관된 객체를 소유합니다. 파일의 소유자로서, 조정 컨트롤러는 nib 파일의 객체 외부에 있으며 해당 개체를 관리합니다. 이러한 소유 객체에는 중재 컨트롤러뿐만 아니라 창 객체 및 뷰 객체가 포함됩니다. 파일의 소유자로서 컨트롤러를 조정하는 것에 대한 자세한 내용은 <a href="#MVC-as-a-Compound-Design-Pattern">복합 디자인 패턴으로서의 MVC</a> 를 참조하십시오.

사용자 지정 `NSObject` 하위 클래스의 인스턴스는 조정 컨트롤러로 완전히 적합할 수 있습니다. 이러한 종류의 컨트롤러 객체는 중재 및 조정 기능을 모두 결합합니다. 그들의 중재 행동을 위해, 그들은 타겟-액션 아울렛, 위임 및 알림과 같은 메커니즘을 사용하여 뷰 객체와 모델 객체 간의 데이터 이동을 용이하게 합니다. 그것들은 많은 접착제 코드를 포함하는 경향이 있으며, 그 코드는 독점적으로 응용 프로그램에 특화되어 있기 때문에 응용 프로그램에서 가장 재사용 가능한 종류의 객체입니다.


{% hint style="info" %} 
**다음에 읽기**
코코아 바인딩 기술에 대한 자세한 내용은 [Cocoa Bindings Programming Topics](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaBindings/CocoaBindings.html#//apple_ref/doc/uid/10000167i) 보세요.
{% endhint %}

## 복합 디자인 패턴으로서의 MVC <a id="MVC-as-a-Compound-Design-Pattern"></a>

모델-뷰-컨트롤러는 몇 가지 더 기본적인 디자인 패턴으로 구성된 디자인 패턴입니다. 이러한 기본 패턴은 MVC 애플리케이션의 특징인 기능적 분리 및 통신 경로를 정의하기 위해 함께 작동합니다. 그러나 MVC의 전통적인 개념은 Cocoa가 할당하는 것과는 다른 기본 패턴 세트를 할당합니다. 차이점은 주로 컨트롤러에 부여된 역할과 애플리케이션의 뷰 객체에 있습니다.

원래 (스몰토크) 개념에서 MVC는 복합, 전략 및 옵저버 패턴으로 구성되어 있습니다.

- 복합 — 응용 프로그램의 뷰 객체는 실제로 조정된 방식(즉, 뷰 계층 구조)으로 함께 작동하는 중첩된 뷰의 합성물입니다. 이러한 디스플레이 구성 요소는 창에서 테이블 뷰와 같은 복합 뷰, 버튼과 같은 개별 뷰에 이르기까지 다양합니다. 사용자 입력 및 표시는 복합 구조의 모든 수준에서 가능합니다.
    
- 전략—컨트롤러 객체는 하나 이상의 뷰 객체에 대한 전략을 구현합니다. 뷰 객체는 시각적 측면을 유지하는 것으로 제한되며, 인터페이스 동작의 애플리케이션 특정 의미에 대한 모든 결정을 컨트롤러에게 위임합니다.
    
- 옵저버—모델 객체는 애플리케이션 내에서 관심 있는 객체들(보통 뷰 객체)에 자신의 상태 변화를 **알립니다**.

복합, 전략 및 옵저버 패턴이 함께 작동하는 전통적인 방식은 그림 7-1에 묘사되어 있습니다: 사용자는 복합 구조의 일부 수준에서 뷰를 조작하고, 결과적으로 이벤트가 생성됩니다. 컨트롤러 객체는 이벤트를 수신하고 애플리케이션 특정 방식으로 해석합니다. 즉, 전략을 적용합니다. 이 전략은 (메시지를 통해) 모델 객체를 요청하여 상태를 변경하거나 뷰 객체(복합 구조의 일부 수준에서)를 요청하여 동작 또는 모양을 변경할 수 있습니다. 모델 객체는, 차례로, 상태가 변경될 때 옵저버로 등록된 모든 객체를 알립니다; 옵저버가 뷰 객체인 경우, 그에 따라 모양을 업데이트할 수 있습니다.

**그림 7-1**  복합 패턴으로서의 MVC의 전통적인 버전

<div align="left">
<img src = https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Art/traditional_mvc.gif width="500" height="auto">
</div>

복합 패턴으로서의 MVC의 코코아 버전은 전통적인 버전과 몇 가지 유사점을 가지고 있으며, 실제로 그림 7-1의 다이어그램을 기반으로 작업 응용 프로그램을 구성하는 것이 매우 가능합니다. 바인딩 기술을 사용하면 뷰가 모델 객체를 직접 관찰하여 상태 변경 알림을 수신하는 Cocoa MVC 애플리케이션을 쉽게 만들 수 있습니다. 그러나, 이 디자인에는 이론적인 문제가 있다. 뷰 객체와 모델 객체는 애플리케이션에서 가장 재사용 가능한 객체여야 합니다. 뷰 객체는 운영 체제와 시스템이 지원하는 애플리케이션의 "모양과 느낌"을 나타냅니다; 외관과 동작의 일관성은 필수적이며, 이를 위해서는 재사용 가능한 객체가 필요합니다. 정의에 따라 모델 객체는 문제 도메인과 관련된 데이터를 캡슐화하고 해당 데이터에 대한 작업을 수행합니다. 디자인적으로, 모델과 뷰 오브젝트를 서로 분리하는 것이 가장 좋습니다. 재사용성이 향상되기 때문입니다.

대부분의 Cocoa 애플리케이션에서, 모델 객체의 상태 변경 알림은 컨트롤러 객체를 통해 뷰 객체에 전달됩니다. 그림 7-2는 두 가지 기본 디자인 패턴이 더 관련되어 있음에도 불구하고 훨씬 더 깔끔해 보이는 이 다른 구성을 보여줍니다.

**그림 7-2**  복합 디자인 패턴으로서의 MVC의 코코아 버전

<div align="left">
<img src = https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Art/cocoa_mvc.gif width="500" height="auto">
</div>

이 복합 디자인 패턴의 컨트롤러 객체는 전략 패턴뿐만 아니라 중재자 패턴을 통합합니다; 그것은 양방향으로 모델과 뷰 객체 간의 데이터 흐름을 중재합니다. 모델 상태의 변경 사항은 애플리케이션의 컨트롤러 객체를 통해 뷰 객체에 전달됩니다. 또한, 뷰 객체는 타겟-액션 메커니즘의 구현을 통해 명령 패턴을 통합합니다.


{% hint style="info" %} 
**노트**
뷰 객체가 사용자 입력과 선택을 전달할 수 있도록 하는 타겟-액션 메커니즘은 컨트롤러 객체를 조정하고 중재하는 데 모두 구현될 수 있습니다. 그러나, 메커니즘의 디자인은 각 컨트롤러 유형마다 다릅니다. 컨트롤러를 조정하려면 인터페이스 빌더에서 뷰 객체를 타겟(컨트롤러 객체)에 연결하고 특정 서명을 준수해야 하는 액션 셀렉터를 지정합니다. 조정 컨트롤러는 윈도우와 글로벌 애플리케이션 객체의 대리인이기 때문에 응답자 체인에도 있을 수 있습니다. 중재 컨트롤러가 사용하는 바인딩 메커니즘은 또한 뷰 객체를 타겟에 연결하고 임의의 유형의 가변 수의 매개 변수로 액션 서명을 허용합니다. 그러나 중재 컨트롤러는 응답자 체인에 있지 않습니다. 
{% endhint %}

특히 중재자 설계 패턴에 관해서는 그림 7-2에 묘사된 개정된 복합 설계 패턴에 대한 이론적 이유뿐만 아니라 실용적인 이유가 있습니다. 중재 컨트롤러는 NSController의 구체적인 하위 클래스에서 파생되며, 이러한 클래스는 중재자 패턴을 구현하는 것 외에도 선택 및 자리 표시자 값 관리와 같이 애플리케이션이 활용해야 할 많은 기능을 제공합니다. 그리고 바인딩 기술을 사용하지 않기로 선택한 경우, 뷰 객체는 모델 개객로부터 알림을 받기 위해 Cocoa 알림 센터와 같은 메커니즘을 사용할 수 있습니다. 그러나 이를 위해서는 모델 객체에 의해 게시된 알림에 대한 지식을 추가하기 위해 사용자 지정  하위 클래스를 만들어야 합니다.

잘 설계된 Cocoa MVC 애플리케이션에서, 조정 컨트롤러 개체는 종종 nib 파일에 보관되는 중재 컨트롤러를 소유합니다. 그림 7-3은 두 가지 유형의 컨트롤러 개체 간의 관계를 보여줍니다.

**그림 7-3**  nib 파일의 소유자로서 컨트롤러 조정

<div align="left">
<img src = https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Art/cocoa_mvc_coord.gif width="300" height="auto">
</div>

## MVC 어플리케이션 디자인 가이드라인들

다음 지침은 애플리케이션 설계 시 모델-뷰-컨트롤러 고려 사항에 적용됩니다:

- [NSObject](https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSObject/Description.html#//apple_ref/occ/cl/NSObject)의 사용자 지정 하위 클래스의 인스턴스를 중재 컨트롤러로 사용할 수 있지만, 하나를 만들기 위해 필요한 모든 작업을 거쳐야 할 이유는 없습니다. 대신 Cocoa 바인딩 기술을 위해 설계된 기성품 [NSController](https://developer.apple.com/documentation/appkit/nscontroller) 객체 중 하나를 사용하십시오. 즉, [NSObjectController](https://developer.apple.com/documentation/appkit/nsobjectcontroller), [NSArrayController](https://developer.apple.com/documentation/appkit/nsarraycontroller), [NSUserDefaultsController](https://developer.apple.com/documentation/appkit/nsuserdefaultscontroller) 또는 [NSTreeController](https://developer.apple.com/documentation/appkit/nstreecontroller)의 인스턴스를 사용하거나 이러한 구체적인 `NSController` 하위 클래스 중 하나의 사용자 지정 하위 클래스를 사용하십시오.
  
  그러나 애플리케이션이 매우 간단하고 콘센트 및 타겟 액션을 사용하여 중재 동작을 구현하는 데 필요한 접착제 코드를 작성하는 것이 더 편안하다고 생각되면 사용자 지정 `NSObject` 하위 클래스의 인스턴스를 중재 컨트롤러로 자유롭게 사용하십시오. 사용자 지정 `NSObject` 하위 클래스에서 키-값 코딩, 키-값 관찰 및 편집기 프로토콜을 사용하여 NSController 의미에서 중재 컨트롤러를 구현할 수도 있습니다.

- MVC 역할을 객체에 결합할 수 있지만, 가장 좋은 전반적인 전략은 역할 간의 분리를 유지하는 것입니다. 이 분리는 객체의 재사용성과 객체가 사용되는 프로그램의 확장성을 향상시킵니다. 클래스에서 MVC 역할을 병합하려는 경우 해당 클래스에 대한 주요 역할을 선택한 다음 (유지 관리 목적으로) 동일한 구현 파일의 범주를 사용하여 클래스를 확장하여 다른 역할을 수행하십시오.

- 잘 설계된 MVC 애플리케이션의 목표는 (이론적으로, 적어도)  많은 객체를 재사용하는 것이어야 합니다. 특히, 뷰 객체와 모델 객체는 재사용성이 높아야 한다. (물론 기성품 중재 컨트롤러 객체는 재사용이 가능합니다.) 애플리케이션 특정 동작은 컨트롤러 객체에 가능한 한 집중되는 경우가 많습니다.

- 상태의 변화를 감지하기 위해 모델을 직접 관찰하는 것은 가능하지만, 그렇게 하지 않는 것이 가장 좋습니다. 뷰 객체는 모델 객체의 변화에 대해 배우기 위해 항상 중재 컨트롤러 객체를 거쳐야 합니다. 그 이유는 두 가지가 있다:
	- 바인딩 메커니즘을 사용하여 뷰 객체가 모델 객체의 속성을 직접 관찰하도록 하는 경우, `NSController` 및 그 하위 클래스가 애플리케이션에 제공하는 모든 이점을 우회합니다: 선택 및 자리 표시자 관리는 물론 변경 사항을 커밋 및 폐기하는 기능.
	- 바인딩 메커니즘을 사용하지 않는 경우, 모델 객체에 의해 게시된 변경 알림을 관찰하는 기능을 추가하기 위해 기존 뷰 클래스를 하위 클래스로 분류해야 합니다.

- 응용 프로그램의 클래스에서 코드 종속성을 제한하기 위해 노력하십시오. 클래스가 다른 클래스에 대한 의존성이 클수록 재사용이 줄어듭니다. 구체적인 권장 사항은 관련된 두 클래스의 MVC 역할에 따라 다릅니다.
	- 뷰 클래스는 모델 클래스에 의존해서는 안 됩니다(일부 사용자 지정 뷰에서는 피할 수 없지만).
	- 뷰 클래스는 중재 컨트롤러 클래스에 의존할 필요가 없어야 합니다.
	- 모델 클래스는 다른 모델 클래스 이외의 다른 것에 의존해서는 안 된다.
	- 중재 컨트롤러 클래스는 모델 클래스에 의존해서는 안 됩니다(비록 뷰와 마찬가지로 사용자 지정 컨트롤러 클래스인 경우 필요할 수 있음).
	- 중재 컨트롤러 클래스는 뷰 클래스 또는 조정 컨트롤러 클래스에 의존해서는 안 됩니다.
	- 조정 컨트롤러 클래스는 모든 MVC 역할 유형의 클래스에 따라 달라집니다.

코코아가 프로그래밍 문제를 해결하는 아키텍처를 제공하고 이 아키텍처가 특정 유형의 객체에 MVC 역할을 할당하는 경우 해당 아키텍처를 사용하십시오. 그렇게 한다면 프로젝트를 정리하는 것이 훨씬 쉬울 것입니다. 예를 들어, 문서 아키텍처에는 [NSDocument](https://developer.apple.com/documentation/appkit/nsdocument) 객체(per-nib 모델 컨트롤러)를 파일 소유자로 구성하는 Xcode 프로젝트 템플릿이 포함됩니다.


## Model-View-Controller in Cocoa (OS X)

모델-뷰-컨트롤러 디자인 패턴은 많은 코코아 메커니즘과 기술의 기본이다. 결과적으로, 객체 지향 설계에서 MVC를 사용하는 것의 중요성은 자신의 애플리케이션에 대해 더 큰 재사용성과 확장성을 달성하는 것 이상입니다. 귀하의 애플리케이션이 MVC 기반인 코코아 기술을 통합하는 경우, 귀하의 애플리케이션은 디자인도 MVC 패턴을 따른다면 가장 잘 작동합니다. 애플리케이션에 MVC 분리가 좋은 경우 이러한 기술을 사용하는 것이 상대적으로 고통스럽지 않지만, 분리가 좋지 않은 경우 이러한 기술을 사용하는 데 더 많은 노력이 필요합니다.

OS X의 Cocoa에는 Model-View-Controller를 기반으로 하는 다음과 같은 아키텍처, 메커니즘 및 기술이 포함되어 있습니다:

- **Document architecture**. 이 아키텍처에서 문서 기반 애플리케이션은 전체 애플리케이션에 대한 컨트롤러 객체([NSDocumentController](https://developer.apple.com/documentation/appkit/nsdocumentcontroller)), 각 문서 창에 대한 컨트롤러 객체([NSWindowController](https://developer.apple.com/documentation/appkit/nswindowcontroller)), 각 문서에 대한 컨트롤러 및 모델 역할을 결합한 객체([NSDocument](https://developer.apple.com/documentation/appkit/nsdocument))로 구성됩니다.

- **바인딩**. MVC는 코코아의 바인딩 기술의 중심이다. 추상 [NSController](https://developer.apple.com/documentation/appkit/nscontroller)의 구체적인 하위 클래스는 뷰 객체와 적절하게 설계된 모델 객체 간의 바인딩을 설정하도록 구성할 수 있는 기성 컨트롤러 개체를 제공합니다.
    
- **Application scriptability**. 스크립트가 가능하도록 응용 프로그램을 설계할 때 MVC 설계 패턴을 따를 뿐만 아니라 응용 프로그램의 모델 객체가 적절하게 설계되어야 합니다. 애플리케이션 상태에 액세스하고 애플리케이션 동작을 요청하는 스크립팅 명령은 일반적으로 모델 객체 또는 컨트롤러 객체로 전송되어야 합니다.
    
- **Core Data**. 코어 데이터 프레임워크는 모델 객체의 그래프를 관리하고 영구 저장소에 저장(그리고 영구 저장소에서 검색)하여 해당 객체의 지속성을 보장합니다. 코어 데이터는 코코아 바인딩 기술과 긴밀하게 통합되어 있습니다. MVC 및 객체 모델링 설계 패턴은 코어 데이터 아키텍처의 필수 결정 요인입니다.

- **Undo**. 실행 취소 아키텍처에서, 모델 객체는 다시 한 번 중심적인 역할을 한다. 모델 객체(일반적으로 접근자 메서드)의 기본 메서드는 종종 실행 취소 및 다시 실행 작업을 구현하는 곳입니다. 액션의 뷰 및 컨트롤러 객체도 이러한 작업에 관련될 수 있습니다. 예를 들어, 이러한 객체가 실행 취소 및 다시 실행 메뉴 항목에 특정 제목을 부여하도록 하거나 텍스트 뷰에서 선택 항목을 실행 취소하도록 할 수 있습니다.